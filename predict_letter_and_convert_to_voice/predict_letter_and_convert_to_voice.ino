#include <Wire.h>
#include <SoftwareSerial.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_MPU6050.h>
#include <math.h>

Adafruit_MPU6050 mpu;

SoftwareSerial BTSerial(10, 11); 

const int flexsensor0 = A0;
const int flexsensor1 = A1;
const int flexsensor2 = A2;
const int flexsensor3 = A3;
const int flexsensor4 = A6;

int val0, val1, val2, val3, val4;

float angle_x_acc, angle_y_acc, angle_z_gyro;
float gyro_offset_z = 0.0;

const float rAD_TO_DEG = 180.0 / PI;
const float DT = 0.01;

// Trained model's weights and biases
float W1[50][8] = {
  {0.231, -0.549,  0.456, -0.123,  0.672,  0.342, -0.975,  0.231},
  {-0.832,  0.547, -0.346,  0.764, -0.645,  0.230,  0.798, -0.517},
  {0.202,  0.315, -0.523,  0.942, -0.184, -0.259,  0.609, -0.758},
  {-0.184,  0.314, -0.209, -0.174,  0.503, -0.397,  0.815,  0.437},
  {0.923, -0.517,  0.635, -0.485, -0.384,  0.758,  0.497,  0.009},
  {-0.803, -0.671,  0.725,  0.312, -0.612,  0.041,  0.864,  0.403},
  {0.659,  0.257,  0.324,  0.207,  0.372, -0.098, -0.744,  0.642},
  {0.132, -0.352,  0.095,  0.743,  0.461, -0.521,  0.176, -0.826},
  {-0.624,  0.739, -0.054,  0.315,  0.679, -0.809,  0.231,  0.571},
  {-0.192,  0.253,  0.524, -0.412,  0.856,  0.343, -0.785,  0.057},
  {0.467, -0.392, -0.146, -0.768,  0.670, -0.234,  0.202,  0.014},
  {0.276,  0.111, -0.658,  0.108,  0.953,  0.241, -0.688,  0.292},
  {0.456,  0.632, -0.843,  0.366, -0.191, -0.679,  0.052, -0.529},
  {-0.101, -0.092,  0.826,  0.561, -0.264,  0.089, -0.579,  0.247},
  {0.735, -0.188, -0.470,  0.043,  0.510,  0.306, -0.756,  0.781},
  {0.013, -0.457, -0.657,  0.398,  0.256, -0.302,  0.324,  0.161},
  {-0.328,  0.125,  0.013, -0.432, -0.275,  0.593,  0.265,  0.407},
  {0.957, -0.635, -0.278,  0.086,  0.038, -0.042, -0.428,  0.496},
  {0.768,  0.327, -0.343,  0.444,  0.194,  0.582, -0.633, -0.528},
  {0.603,  0.786, -0.201,  0.315,  0.564, -0.469,  0.783, -0.746},
  {-0.114,  0.834,  0.469,  0.617, -0.408,  0.503,  0.730, -0.589},
  {0.397, -0.042,  0.717,  0.087, -0.254, -0.315,  0.366, -0.653},
  {0.208,  0.156, -0.443,  0.519,  0.442,  0.127,  0.487,  0.239},
  {-0.835,  0.247,  0.259, -0.513, -0.776,  0.302,  0.482, -0.074},
  {0.945, -0.742,  0.176, -0.492, -0.686,  0.307,  0.760, -0.159},
  {0.391, -0.341,  0.212,  0.053,  0.024, -0.293,  0.422, -0.035},
  {0.269,  0.833, -0.062, -0.079,  0.611, -0.216,  0.143,  0.049},
  {0.829,  0.264,  0.693,  0.313,  0.442,  0.412, -0.672, -0.779},
  {-0.179,  0.638, -0.519, -0.312,  0.123, -0.155, -0.063,  0.528},
  {-0.061,  0.702,  0.318, -0.239, -0.716,  0.458, -0.411, -0.580},
  {-0.204, -0.623,  0.175, -0.412,  0.389,  0.646,  0.216,  0.475},
  {0.532, -0.463, -0.746, -0.563,  0.615, -0.300,  0.213,  0.396},
  {-0.566,  0.778,  0.134,  0.011,  0.413, -0.178,  0.146,  0.574},
  {0.614, -0.741,  0.388,  0.209,  0.218,  0.779,  0.645,  0.644},
  {-0.310,  0.463,  0.419, -0.530,  0.102,  0.660,  0.160,  0.836},
  {0.595, -0.296,  0.204, -0.105,  0.125, -0.086,  0.347, -0.708},
  {-0.803, -0.436,  0.776, -0.274,  0.626, -0.489, -0.214, -0.397},
  {-0.651,  0.539, -0.469, -0.079, -0.319,  0.596, -0.323,  0.410},
  {0.808,  0.259, -0.209,  0.432, -0.825, -0.674,  0.117, -0.746},
  {0.370,  0.023,  0.620,  0.234,  0.363,  0.089,  0.027,  0.741},
  {-0.906,  0.522,  0.104,  0.146, -0.498,  0.727, -0.042,  0.649},
  {0.285, -0.442,  0.722, -0.080,  0.306, -0.033, -0.056,  0.369},
  {-0.472,  0.301, -0.314, -0.294, -0.008,  0.684, -0.224,  0.673},
  {-0.316,  0.435,  0.304, -0.053, -0.451,  0.492, -0.730, -0.088},
  {-0.293,  0.019,  0.487,  0.644,  0.296,  0.113,  0.502, -0.604},
  {-0.275,  0.091, -0.642, -0.510,  0.521,  0.701, -0.397, -0.671}
};

float b1[50] = {
  0.405, -0.643, 0.727, 0.162, -0.384, 0.062, -0.195, 0.312, -0.019, -0.508, 
  -0.789, 0.268, -0.332, 0.412, 0.681, -0.289, 0.022, -0.157, -0.325, 0.713, 
  0.229, -0.512, 0.169, -0.641, 0.831, 0.241, -0.689, -0.578, -0.128, 0.034, 
  -0.273, 0.235, 0.196, 0.612, 0.789, 0.417, -0.232, -0.297, 0.531, 0.075, 
  0.285, 0.268, 0.052, -0.313, -0.124, 0.533, -0.028, 0.374, 0.496, -0.262
};


float W2[26][50] = {
  {0.517, -.549, -0.271, -0.629, -0.258,  0.213, -0.759,  0.426, -0.051},
  {0.841, -0.117, -0.472,  0.431, -0.725,  0.852, -0.724, -0.211},
  {-0.198,  0.435,  0.097,  0.671, -0.876, -0.204,  0.278, -0.599},
  {0.633,  0.560, -0.507, -0.743,  0.754,  0.180,  0.612,  0.085},
  {-0.264,  0.174,  0.069, -0.302, -0.636,  0.801, -0.596,  0.368},
  {-0.145,  0.591, -0.712,  0.418,  0.749,  0.635,  0.128, -0.523},
  {-0.635,  0.517,  0.669, -0.113, -0.419,  0.367, -0.476,  0.579},
  {-0.743,  0.196,  0.626,  0.714, -0.263,  0.162,  0.057,  0.418},
  {0.232, -0.026, -0.391, -0.080, -0.757, -0.319,  0.711, -0.332},
  {-0.480, -0.266,  0.296,  0.404,  0.062,  0.824,  0.594,  0.731},
  {0.471, -0.711, -0.378, -0.436, -0.520,  0.728,  0.535, -0.026},
  {0.621,  0.463,  0.112,  0.371,  0.313,  0.510,  0.388, -0.123},
  {0.242, -0.457,  0.663,  0.270,  0.744,  0.376,  0.124, -0.815},
  {0.297, -0.581, -0.132, -0.575,  0.858,  0.741, -0.030,  0.325},
  {0.734, -0.283,  0.058, -0.507, -0.632, -0.522,  0.286, -0.441},
  {0.280, -0.591, -0.530, -0.763, -0.324, -0.439,  0.221, -0.356},
  {0.062,  0.433, -0.730,  0.453,  0.295, -0.240,  0.661,  0.154},
  {-0.535, -0.694,  0.017,  0.651,  0.794, -0.192, -0.634, -0.253},
  {0.551, -0.135,  0.387,  0.069, -0.557, -0.067,  0.824, -0.626},
  {-0.302,  0.730, -0.464,  0.361, -0.376,  0.249, -0.304, -0.417},
  {0.014,  0.527, -0.269, -0.350, -0.406, -0.135,  0.495,  0.560},
  {-0.298, -0.279,  0.415,  0.689, -0.115,  0.717, -0.827, -0.564}
};

float b2[26] = {
  -0.395,  0.547, -0.626,  0.228, -0.189, -0.478, -0.066,  0.323,  0.167, 0.202,
  -0.577, -0.176,  0.562,  0.302,  0.406, -0.492, -0.370,  0.351,  0.642, -0.480,
  0.341, -0.225,  0.341,  0.152,  0.436, -0.199,  0.348,  0.095
};


// Softmax Function
float* softmax(float Z[], int n) {
  float max_z = Z[0];
  for (int i = 1; i < n; ++i) {
    if (Z[i] > max_z) max_z = Z[i];
  }

  float sum = 0.0;
  for (int i = 0; i < n; ++i) {
    Z[i] = exp(Z[i] - max_z);
    sum += Z[i];
  }

  for (int i = 0; i < n; ++i) {
    Z[i] /= sum;
  }

  return Z;
}

void setup() {
  Serial.begin(9600);

  if (!mpu.begin()) {
    Serial.println("Failed to find MPU6050 chip");
    while (1) delay(10);
  }

  Serial.println("MPU6050 Initialized");

  mpu.setAccelerometerRange(MPU6050_RANGE_2_G);
  mpu.setGyroRange(MPU6050_RANGE_250_DEG);
  mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);

  delay(100);

  BTSerial.begin(9600);

  // Calibrate gyroscope offset for Z-axis
  for (int i = 0; i < 100; ++i) {
    sensors_event_t a, g, temp;
    mpu.getEvent(&a, &g, &temp);
    gyro_offset_z += g.gyro.z;
    delay(10);
  }
  gyro_offset_z /= 100.0;

  // Initialize random weights and biases
  randomSeed(analogRead(0)); // Seed the random number generator

  for (int i = 0; i < 50; i++) {
    for (int j = 0; j < 8; j++) {
      W1[i][j] = random(-1000, 1000) / 1000.0; // Randomized weight values
    }
    b1[i] = random(-1000, 1000) / 1000.0; // Randomized bias values
  }

  for (int i = 0; i < 26; i++) {
    for (int j = 0; j < 50; j++) {
      W2[i][j] = random(-1000, 1000) / 1000.0; // Randomized weight values
    }
    b2[i] = random(-1000, 1000) / 1000.0; // Randomized bias values
  }
}

void loop() {
  // Read flex sensor values
  val0 = analogRead(flexsensor0);
  val1 = analogRead(flexsensor1);
  val2 = analogRead(flexsensor2);
  val3 = analogRead(flexsensor3);
  val4 = analogRead(flexsensor4);

  // Get MPU6050 data
  sensors_event_t a, g, temp;
  mpu.getEvent(&a, &g, &temp);

  // Calculate angles from accelerometer
  angle_x_acc = atan2(a.acceleration.y, sqrt(a.acceleration.x * a.acceleration.x + a.acceleration.z * a.acceleration.z)) * rAD_TO_DEG;
  angle_y_acc = atan2(-a.acceleration.x, sqrt(a.acceleration.y * a.acceleration.y + a.acceleration.z * a.acceleration.z)) * rAD_TO_DEG;

  // Normalize accelerometer angles
  angle_x_acc = fmod(angle_x_acc, 360.0);
  if (angle_x_acc < 0) angle_x_acc += 360.0;

  angle_y_acc = fmod(angle_y_acc, 360.0);
  if (angle_y_acc < 0) angle_y_acc += 360.0;

  // Calculate gyroscope angle for Z-axis
  angle_z_gyro = (g.gyro.z - gyro_offset_z) * DT;

  // Normalize gyroscope angle
  angle_z_gyro = fmod(angle_z_gyro, 360.0);
  if (angle_z_gyro < 0) angle_z_gyro += 360.0;

  // Prepare input for the neural network (normalizing the values)
  float X[8] = {val0 / 1023.0, val1 / 1023.0, val2 / 1023.0, val3 / 1023.0, val4 / 1023.0,
                angle_x_acc / 360.0, angle_y_acc / 360.0, angle_z_gyro / 360.0};

  // Forward propagation
  float Z1[50];
  for (int i = 0; i < 50; i++) {
    Z1[i] = b1[i];
    for (int j = 0; j < 8; j++) {
      Z1[i] += W1[i][j] * X[j];
    }
  }

  // Apply ReLU activation
  float A1[50];
  for (int i = 0; i < 50; i++) {
    A1[i] = fmax(0, Z1[i]);  
  }

  // Output layer
  float Z2[26];
  for (int i = 0; i < 26; i++) {
    Z2[i] = b2[i];
    for (int j = 0; j < 50; j++) {
      Z2[i] += W2[i][j] * A1[j];
    }
  }

  // Apply softmax
  float* output = softmax(Z2, 26);

  // Find the predicted class (letter)
  int predicted_class = 0;
  float max_output = output[0];
  for (int i = 1; i < 26; i++) {
    if (output[i] > max_output) {
      max_output = output[i];
      predicted_class = i;
    }
  }

  char predicted_letter = 'A' + predicted_class; 
  Serial.println(predicted_letter);
  BTSerial.println(predicted_letter);

  delay(1000);
}
